# Instructions

- Following Playwright test failed.
- Explain why, be concise, respect Playwright best practices.
- Provide a snippet of code with the fix, if possible.

# Test info

- Name: Verify hotel availability and filter based on New York City
- Location: C:\Users\aavila\Desktop\Challenge-Automation\challenge-playwright\tests\homepage.spec.js:13:1

# Error details

```
Error: locator.hover: Target page, context or browser has been closed
Call log:
  - waiting for locator('[data-testid="address"]').nth(24)
    - locator resolved to <span data-testid="address" class="aee5343fdb def9bc142a">Candelaria - Centro Historico, Bogotá</span>
  - attempting hover action
    - waiting for element to be visible and stable
    - element is visible and stable
    - scrolling into view if needed
    - done scrolling
    - <h2 class="f2cf178bcd df11f444aa">…</h2> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  - retrying hover action
    - waiting for element to be visible and stable
    - element is visible and stable
    - scrolling into view if needed
    - done scrolling
    - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  - retrying hover action
    - waiting 20ms
    - waiting for element to be visible and stable
    - element is visible and stable
    - scrolling into view if needed
    - done scrolling
    - <h2 class="f2cf178bcd df11f444aa">…</h2> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  2 × retrying hover action
      - waiting 100ms
      - waiting for element to be visible and stable
      - element is visible and stable
      - scrolling into view if needed
      - done scrolling
      - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  9 × retrying hover action
      - waiting 500ms
      - waiting for element to be visible and stable
      - element is visible and stable
      - scrolling into view if needed
      - done scrolling
      - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
    - retrying hover action
      - waiting 500ms
      - waiting for element to be visible and stable
      - element is visible and stable
      - scrolling into view if needed
      - done scrolling
      - <h2 class="f2cf178bcd df11f444aa">…</h2> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
    - retrying hover action
      - waiting 500ms
      - waiting for element to be visible and stable
      - element is visible and stable
      - scrolling into view if needed
      - done scrolling
      - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
    - retrying hover action
      - waiting 500ms
      - waiting for element to be visible and stable
      - element is visible and stable
      - scrolling into view if needed
      - done scrolling
      - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  - retrying hover action
    - waiting 500ms
    - waiting for element to be visible and stable
    - element is visible and stable
    - scrolling into view if needed
    - done scrolling
    - <div class="eb33ef7c47">…</div> from <div class="b9720ed41e cdf0a9297c">…</div> subtree intercepts pointer events
  - retrying hover action
    - waiting 500ms

    at SearchPage.getElementsWithFormattedText (C:\Users\aavila\Desktop\Challenge-Automation\challenge-playwright\pages\base.page.js:84:71)
    at SearchPage.getNumberResults (C:\Users\aavila\Desktop\Challenge-Automation\challenge-playwright\pages\search.page.js:47:16)
    at C:\Users\aavila\Desktop\Challenge-Automation\challenge-playwright\tests\homepage.spec.js:29:32
```

# Test source

```ts
   1 | export default class BasePage {
   2 |     /**
   3 |      * @param {import('@playwright/test').Page} page
   4 |      */
   5 |     constructor(page) {
   6 |         this.page = page;
   7 |     }
   8 |
   9 |     async findLocator(selector) {
   10 |         const locator = this.page.locator(selector);
   11 |         return locator;
   12 |     }
   13 |
   14 |     async findLocatorFromArray(selectors) {
   15 |         for (const selector of selectors) {
   16 |             const locator = this.page.locator(selector);
   17 |             const count = await locator.count();
   18 |             if (count > 0) {
   19 |                 return locator;
   20 |             }
   21 |         }
   22 |     }
   23 |
   24 |     async findSelfHealingLocator(selector) {
   25 |         if (Array.isArray(selector)) {
   26 |             return this.findLocatorFromArray(selector); // Array
   27 |         } else {
   28 |             return this.findLocator(selector); // String
   29 |         }
   30 |     }
   31 |
   32 |     async click(selector) {
   33 |         const element = await this.findSelfHealingLocator(selector);
   34 |         await element.click();
   35 |     }
   36 |
   37 |     async goToUrl(url) {
   38 |         await this.page.goto(url, { waitUntil: 'load' });
   39 |     }
   40 |
   41 |     async type(selector, text) {
   42 |         const element = await this.findSelfHealingLocator(selector);
   43 |         await element.focus();
   44 |         await element.fill(text);
   45 |     }
   46 |
   47 |     async waitForPageLoad() {
   48 |         await this.page.waitForLoadState('load');
   49 |     }
   50 |
   51 |     async waitForTimeout(ms = 2000) {
   52 |         await this.page.waitForTimeout(ms);
   53 |     }
   54 |
   55 |     async waitForVisibleOption(text) {
   56 |         const selector = `input[value="${text}"]`;
   57 |         await this.waitForElement(selector);
   58 |     }
   59 |
   60 |     async waitForElement(selector) {
   61 |         const element = await this.findSelfHealingLocator(selector);
   62 |         await element.waitFor({ state: 'attached' });
   63 |     }
   64 |
   65 |     async getText(selector) {
   66 |         await this.waitForPageLoad();
   67 |         const element = await this.findSelfHealingLocator(selector);
   68 |         const textContent = await element.textContent();
   69 |         return textContent;
   70 |     }
   71 |
   72 |     async countElementsContainingText(selector, text) {
   73 |         const elementLocator = await this.findSelfHealingLocator(selector);
   74 |         const elements = await elementLocator.all();
   75 |         const texts = await Promise.all(elements.map(async element => await element.textContent()));
   76 |         return texts.filter(elementText => elementText && elementText.includes(text)).length;
   77 |     }
   78 |
   79 |     async getElementsWithFormattedText(selector, text) {
   80 |         const elementLocator = await this.findSelfHealingLocator(selector);
   81 |         
   82 |         const elementsBeforeHover = await elementLocator.all();
   83 |         if (elementsBeforeHover.length > 0) {
>  84 |             await elementsBeforeHover[elementsBeforeHover.length - 1].hover();
      |                                                                       ^ Error: locator.hover: Target page, context or browser has been closed
   85 |             await this.waitForTimeout(); 
   86 |         }
   87 |
   88 |         const elementsAfterHover = await elementLocator.all();
   89 |         const texts = await Promise.all(elementsAfterHover.map(async element => await element.textContent()));
   90 |
   91 |         const regex = new RegExp(`(^${text}$|, ${text}$)`, 'i');
   92 |
   93 |         const matchingTexts = texts.filter(elementText => elementText && regex.test(elementText.trim())).length;
   94 |         
   95 |         return matchingTexts.toString(); 
   96 |     }
   97 |
   98 |
   99 |     async getElementsWithExactText(selector, text) {
  100 |         const elementLocator = await this.findSelfHealingLocator(selector);
  101 |         
  102 |         const elementsBeforeHover = await elementLocator.all();
  103 |         if (elementsBeforeHover.length > 0) {
  104 |             await elementsBeforeHover[elementsBeforeHover.length - 1].hover(); 
  105 |             await this.waitForTimeout(); 
  106 |         }
  107 |
  108 |         const elementsAfterHover = await elementLocator.all();
  109 |         const texts = await Promise.all(elementsAfterHover.map(async element => await element.textContent()));
  110 |
  111 |         const matchingTexts = texts.filter(elementText => elementText && elementText.trim() === text).length;
  112 |         
  113 |         return matchingTexts.toString(); 
  114 |     }
  115 |
  116 |     async getElementsContainingTextWithHover(selector, text) {
  117 |         const elementLocator = await this.findSelfHealingLocator(selector);
  118 |         
  119 |         const elementsBeforeHover = await elementLocator.all();
  120 |         if (elementsBeforeHover.length > 0) {
  121 |             await elementsBeforeHover[elementsBeforeHover.length - 1].hover(); 
  122 |             await this.waitForTimeout(); 
  123 |         }
  124 |
  125 |         const elementsAfterHover = await elementLocator.all();
  126 |         const texts = await Promise.all(elementsAfterHover.map(async element => await element.textContent()));
  127 |
  128 |         const matchingTexts = texts.filter(elementText => elementText && elementText.includes(text)).length;
  129 |         
  130 |         return matchingTexts.toString();
  131 |     }
  132 |
  133 |     async getElementsContainingText(selector, text) {
  134 |         const elementLocator = await this.findSelfHealingLocator(selector);
  135 |         const elements = await elementLocator.all();        
  136 |         const texts = await Promise.all(elements.map(async element => await element.textContent()));    
  137 |         const matchingTexts = texts.filter(elementText => elementText && elementText.includes(text)).length;    
  138 |         return matchingTexts.toString(); 
  139 |     }
  140 |
  141 |     async filterByText(selector, text) {
  142 |         const elementLocator = await this.findSelfHealingLocator(selector);
  143 |         return elementLocator.filter({ hasText: text }).first();
  144 |     }
  145 |
  146 |     async checkElementIsPresent(selector) {
  147 |         try {
  148 |             await this.page.locator(selector).waitFor({ state: 'visible', timeout: 1000 });
  149 |             return true; 
  150 |         } catch {
  151 |             return false; 
  152 |         }
  153 |     }
  154 |
  155 |     async countTextContents(selector) {
  156 |         await this.page.waitForTimeout(5000);
  157 |         const elementLocator = await this.findSelfHealingLocator(selector);
  158 |         return await elementLocator.allTextContents();
  159 |     }
  160 | }
  161 |
```